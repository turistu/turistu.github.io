<!DOCTYPE HTML>
<title>a simple TOTP generator</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
input:invalid { background-color: red; color: pink }
#error { color: red; font-weight: bold; height: 1em }
input:invalid ~ #error:empty::after {
	content: 'ERROR: only letters and digits from 2 to 7 allowed'
}
#code { font-size: 250%; letter-spacing: .15em; font-family: monospace }
#code::after { all: initial; content: attr(title); height: 1em; color: red }
#code::after { display: block; font-size: 30% }
#code[title^=copied]::after { color: green }
input { max-width: 100%; white-space: normal }
[autocomplete] {
	width: 100%; max-width: 25em; min-width: 5em; box-sizing: border-box
}
input:not([type=checkbox]) { display: block; font-size: 110% }
form > * { display: block; margin-bottom: 1em }
</style>
<iframe name=fram style=display:none></iframe>
<form target=fram>
    <label>User<input id=user autocomplete=username></label>
    <div>
	<label for=key>Shared Key</label>
	<label><input type=checkbox id=show>show</label>
	<input id=key autocomplete=current-password type=password pattern="[a-zA-Z2-7\s]+">
	<div id=error></div>
    </div>
    <div id=code>XXXXXX</div>
    <input type=button id=generate value="Generate TOTP (and copy it to clipboard)">
    <input type=submit value="Save the key (with the browser's password manager)">
</form>
The TOTP shared key should be in base32 format,
eg <code>TK7P33KPE527ZTOX</code> (github) or <code>opid zgaw quda ip7q tj3z izo7 oemp t7dm</code> (google).
<p>The <q>User</q> field is not used for computing the TOTP; its only purpose is to act as a label for the password manager.
<p>If the <q>Save..</q> button does not pop up the <q>Save login/password</q> dialog, look for a key-like icon in the address bar and click on it. If there's no such icon, check if your browser's settings prevent it from saving passwords on this page.
<hr>
<p>This is a javascript implementation of a <a href=https://www.rfc-editor.org/rfc/rfc6238>TOTP</a> generator,
using the browser's <a href=https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto>crypto API</a>.
It should do the exactly same thing as the google authenticator or any other TOTP generating app.

<p>The <a href=#source>javascript code</a> does not send to or fetch any data from anywhere
remotely, and the <a href=https://turistu.github.io/totp.html>demo page</a> should
work the same when served over https, saved locally or used inside a browser
extension.

<p>I have also packaged this into an <a href=https://addons.mozilla.org/en-US/firefox/addon/totp/>xpi firefox browser extension</a>, which offers the
convenience of generating the TOTP (for a key you have saved) directly from
a toolbar popup instead of having to switch to another tab. The xpi does not
do anything more than that and does not include any content scripts or filters.
<script>
function qs(s){ return document.querySelector(s) || {} }
function generate(){
	totp(qs('#key').value).then(c => {
		qs('#code').textContent = c; copy();
	}).catch(error => {
		qs('#error').textContent = 'ERROR: ' + error;
		qs('#key').setCustomValidity('failed');
	})
}
function copy(event){
	const code = qs('#code');
	navigator.clipboard.writeText(code.textContent).then(() => {
		code.title = 'copied!';
		if(navigator.userAgent.includes("(X11;"))
			getSelection().selectAllChildren(code);
	}).catch(error => {
		code.title = event ? 'copy failed' : 'click to copy';
	})
}
qs('#generate').onclick = generate;
qs('#key').oninput = function(){
	this.setCustomValidity(''); qs('#error').innerHTML = '';
	if(this !== document.activeElement) generate();
}
qs('#show').checked = false;
qs('#show').onchange = function(){
	qs('#key').type = this.checked ? 'text': 'password';
}
qs('#code').onclick = copy;
if(window.PasswordCredential)
	qs('form').onsubmit = function(e){
		navigator.credentials.store(new PasswordCredential({
			id: qs('#user').value, password: qs('#key').value
		}));
		e.preventDefault();
	}
</script>
<script style="display: block; white-space: pre; font-family: monospace; overflow: auto">
async function totp(key){
	return hotp(unbase32(key), pack64bu(Date.now() / 30000));
}
async function hotp(key, counter){
	const y = window.crypto.subtle;
	if(!y) throw 'no window.crypto.subtle object available';
	const k = await y.importKey('raw', key, {name: "HMAC", hash: "SHA-1"}, false, ['sign']);
	return hotp_truncate(await y.sign('HMAC', k, counter));
}
function hotp_truncate(b){
	const a = new Uint8Array(b), i = a[19] & 0xf;
	return fmt(10, 6, ((a[i]&0x7f)<<24|a[i+1]<<16|a[i+2]<<8|a[i+3]) % 1000000);
}

function fmt(base, width, num){
	return num.toString(base).padStart(width, '0')
}
function unbase32(s){
	const t = s?.toLowerCase().match(/\S/g)?.map(c => {
		const i = "abcdefghijklmnopqrstuvwxyz234567".indexOf(c);
		if(i < 0) throw `bad char '${c}' in key`;
		return fmt(2, 5, i);
	}).join("");
	if(!t) throw `empty key`;
	if(t.length & 7) throw `bad ${t.length} bits key length`;
	return new Uint8Array(t.match(/.{8}/g).map(d => parseInt(d, 2)));
}
function pack64bu(v){
	let b = new ArrayBuffer(8), d = new DataView(b);
	d.setUint32(0, v / 4294967296);
	d.setUint32(4, v);
	return b;
}
</script>
