<!DOCTYPE HTML>
<title>a simple TOTP generator</title>
<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
#error { font-weight: bold; color: red; display: block; height: 1em }
#key:invalid { background-color: red; color: pink }
#code { font-family: monospace; font-size: 250%; letter-spacing: .15em }
#code::after { all: initial; content: ' ' attr(title); color: red }
#code[title^=copied]::after { color: green }

input, button { box-sizing: border-box; width: 100%; font-size: inherit }
input { max-width: 25em }
button { max-width: max-content }
#add { display: none }
#show { width: unset }

.popup :not(p, #user, #code), .popup ~ * { display: none }
.popup #user, .popup #code { all: revert }
.popup p { margin: .5em 0 }
.popup #code::after { font-size: 80% }
.popup #add { display: inline; float: right }
</style>

<iframe name=fram style=display:none></iframe>
<form target=fram>
    <label for=user>User</label><br>
    <input id=user size=24 autocomplete=username>
  <p>
    <label for=key>Shared Key</label>
    <label><input type=checkbox id=show>show</label><br>
    <input id=key size=24 autocomplete=current-password type=password pattern="[a-zA-Z2-7\s]+">
    <output for=key id=error></output>
  <p>
    <output for=key id=code>XXXXXX</output>
    <a id=add href target=_blank>add key</a>
  <p><button type=button id=generate>Generate TOTP (and copy it to clipboard)</button>
  <p><button>Save the key (with the browser's password manager)</button>
</form>

<p>The TOTP shared key should be in base32 format, e.g. <code>TK7P33KPE527ZTOX</code> (github) or <code>opid zgaw quda ip7q tj3z izo7 oemp t7dm</code> (google).

<p>The <q>User</q> field is not used for computing the TOTP; its only purpose is to act as a label for the password manager.

<p>If the <q>Save..</q> button does not pop up the <q>Save login/password</q> dialog, look for a key-like icon in the address bar and click on it. If there's no such icon, check if your browser's settings prevent it from saving passwords on this page.
<hr>
<p>This is a javascript implementation of a <a href=https://www.rfc-editor.org/rfc/rfc6238>TOTP</a> generator,
using the browser's <a href=https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto>crypto API</a>.
It should do the exactly same thing as the google authenticator or any other TOTP generating app.

<p>The <a href=#source>javascript code</a> does not send to or fetch any data from anywhere
remotely, and the <a href=https://turistu.github.io/totp.html>demo page</a> should
work the same when served over https, saved locally or used inside a browser
extension.

<p>I have also packaged this into an <a href=https://addons.mozilla.org/en-US/firefox/addon/totp/>xpi firefox browser extension</a>, which offers the
convenience of generating the TOTP (for a key you have saved) directly from
a toolbar popup instead of having to switch to another tab. The xpi does not
do anything more than that and does not include any content scripts or filters.
<script>
function qs(s){ return document.querySelector(s) }
function generate(){
	totp(qs('#key').value).then(c => {
		qs('#code').value = c; copy('click to copy');
	}).catch(e => {
		qs('#key').setCustomValidity(e);
		qs('#error').value = 'ERROR: ' + e;
	})
}
function copy(emsg){
	navigator.clipboard.writeText(qs('#code').value).then(() => {
		qs('#code').title = 'copied!';
		if(navigator.userAgent.includes("(X11;"))
			getSelection().selectAllChildren(qs('#code'));
	}).catch(e => qs('#code').title = emsg);
}
qs('#generate').onclick = generate;
qs('#key').oninput = function(){
	this.setCustomValidity('');
	qs('#error').value = this.checkValidity() ?
		'' : 'ERROR: only A..Z, 2..7 and spaces allowed';
	if(this !== document.activeElement) generate();
}
qs('#show').checked = false;
qs('#show').onchange = function(){
	qs('#key').type = this.checked ? 'text': 'password';
}
qs('#code').onclick = e => copy('copy failed');
qs('form').className = document.location.hash.substr(1);
// this currently only seems to work in chrome
// where it is also the most reliable way, though it still does not work
// with with file:// and chrome-extension:// urls
if(window.PasswordCredential)
	qs('form').onsubmit = function(e){
		navigator.credentials.store(new PasswordCredential({
			id: qs('#user').value, password: qs('#key').value
		}));
		e.preventDefault();
	}
</script>
<script id=source style="display: block; white-space: pre; font-family: monospace; overflow: auto">
async function totp(key, secs = 30, digits = 6){
	return hotp(unbase32(key), pack64bu(Date.now() / 1000 / secs), digits);
}
async function hotp(key, counter, digits){
	const y = window.crypto.subtle;
	if(!y) throw 'no window.crypto.subtle object available';
	const k = await y.importKey('raw', key, {name: "HMAC", hash: "SHA-1"}, false, ['sign']);
	return hotp_truncate(await y.sign('HMAC', k, counter), digits);
}
function hotp_truncate(buf, digits){
	const a = new Uint8Array(buf), i = a[19] & 0xf;
	return fmt(10, digits,
		((a[i]&0x7f)<<24|a[i+1]<<16|a[i+2]<<8|a[i+3]) % 10**digits);
}

function fmt(base, width, num){
	return num.toString(base).padStart(width, '0')
}
function unbase32(s){
	const t = s.toLowerCase().match(/\S/g)?.map(c => {
		const i = "abcdefghijklmnopqrstuvwxyz234567".indexOf(c);
		if(i < 0) throw `bad char '${c}' in key`;
		return fmt(2, 5, i);
	}).join("");
	if(!t || t.length < 8) throw 'key too short';
	return new Uint8Array(t.match(/.{8}/g).map(d => parseInt(d, 2)));
}
function pack64bu(v){
	let b = new ArrayBuffer(8), d = new DataView(b);
	d.setUint32(0, v / 2**32);
	d.setUint32(4, v);
	return b;
}
</script>
